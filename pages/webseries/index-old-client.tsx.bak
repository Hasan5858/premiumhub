import { GetServerSideProps } from "next"
import Head from "next/head"
import Link from "next/link"
import { Play, Clock, ChevronLeft, ChevronRight } from "lucide-react"
import { fetchLatestWebseries } from "@/services/api"
import { useNavigation } from "@/contexts/NavigationContext"
import { useSidebar } from "@/contexts/SidebarContext"
import type { WebseriesPost } from "@/types"
import { API_BASE_URL } from "@/utils/api-url"

interface MergedWebseries {
  id: string
  title: string
  thumbnail: string
  duration: string
  quality: string
  link: string
  source: 'webseries' | 'webxseries'
  badge: string
}

export default function WebseriesPage() {
  const router = useRouter()
  const { page } = router.query
  const [webseries, setWebseries] = useState<WebseriesPost[]>([])
  const [webxseriesVideos, setWebxseriesVideos] = useState<any[]>([])
  const [loading, setLoading] = useState(false)
  const [loadingMore, setLoadingMore] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const { navigationState, setWebseriesPage } = useNavigation()
  const { isCollapsed } = useSidebar()
  const [currentPage, setCurrentPage] = useState(1)
  const [totalPages, setTotalPages] = useState(1)
  const [hasNextPage, setHasNextPage] = useState(false)

  // Items per page: 20
  const itemsPerPage = 20

  // Set initial page from URL or navigation state
  useEffect(() => {
    if (router.isReady) {
      let initialPage = 1
      
      // First priority: URL parameter
      if (page && !Array.isArray(page)) {
        const pageNum = parseInt(page, 10)
        if (!isNaN(pageNum) && pageNum > 0) {
          initialPage = pageNum
        }
      } 
      // Second priority: navigation state
      else if (navigationState.webseriesPage > 1) {
        initialPage = navigationState.webseriesPage
      }
      
      setCurrentPage(initialPage)
    }
  }, [router.isReady, page, navigationState.webseriesPage])

  const loadMoreWebseries = async (page: number) => {
    console.log(`Loading more webseries for page ${page}`)
    setLoadingMore(true)
    try {
      // Fetch old webseries for this page
      const oldWebseriesData = await fetchLatestWebseries(page)
      const newOldWebseries = oldWebseriesData.posts || []
      console.log(`Fetched ${newOldWebseries.length} old webseries from page ${page}`)
      
      // Calculate WebXSeries page needed based on current page
      // Since we show 20 items per page with 2:1 ratio, we need ~7 WebXSeries per page
      const webxseriesPage = Math.ceil(page / 3) // Fetch new WebXSeries every 3 pages
      const webxseriesLimit = 100 // Fetch 100 at a time
      
      const webxseriesResponse = await fetch(
        `/api/v2/providers/webxseries/videos?page=${webxseriesPage}&limit=${webxseriesLimit}`
      )
      const webxseriesData = await webxseriesResponse.json()
      const newWebxseries = webxseriesData.success && webxseriesData.data ? webxseriesData.data : []
      console.log(`Fetched ${newWebxseries.length} WebXSeries from page ${webxseriesPage}`)
      
      // Add new data to existing arrays (avoiding duplicates)
      setWebseries(prev => {
        const existingIds = new Set(prev.map((w: any) => w.id))
        const uniqueNew = newOldWebseries.filter((w: any) => !existingIds.has(w.id))
        console.log(`Adding ${uniqueNew.length} new old webseries (${newOldWebseries.length - uniqueNew.length} duplicates)`)
        return [...prev, ...uniqueNew]
      })
      
      setWebxseriesVideos(prev => {
        const existingIds = new Set(prev.map((w: any) => w.id))
        const uniqueNew = newWebxseries.filter((w: any) => !existingIds.has(w.id))
        console.log(`Adding ${uniqueNew.length} new WebXSeries (${newWebxseries.length - uniqueNew.length} duplicates)`)
        return [...prev, ...uniqueNew]
      })
      
      setTotalPages(oldWebseriesData.total_pages || 1)
      setHasNextPage(oldWebseriesData.has_next_page || false)
    } catch (err) {
      console.error("Error loading more webseries:", err)
    } finally {
      setLoadingMore(false)
    }
  }

  const loadWebseries = async (pageNum: number) => {
    // Check if we have cached data before showing loading indicator
    const hasWebseriesCache = hasCacheItem(`latest-webseries-page-1`);
    
    if (!hasWebseriesCache) {
      setLoading(true);
    }
    
    try {
      setError(null)

      // Initial load: Fetch first 5 pages of old webseries and first batch of WebXSeries
      // This gives us enough for ~7-8 pages of merged content
      const data1 = await fetchLatestWebseries(1)
      const data2 = await fetchLatestWebseries(2)
      const data3 = await fetchLatestWebseries(3)
      const data4 = await fetchLatestWebseries(4)
      const data5 = await fetchLatestWebseries(5)
      
      const allWebseries = [
        ...(data1.posts || []),
        ...(data2.posts || []),
        ...(data3.posts || []),
        ...(data4.posts || []),
        ...(data5.posts || [])
      ]
      
      console.log(`Initial load: ${allWebseries.length} old webseries items`)
      
      setWebseries(allWebseries)

      // Fetch initial WebXSeries videos - increased to 150 for better coverage
      const webxseriesResponse = await fetch(`/api/v2/providers/webxseries/videos?page=1&limit=150`)
      const webxseriesData = await webxseriesResponse.json()
      if (webxseriesData.success && webxseriesData.data) {
        console.log(`Initial load: ${webxseriesData.data.length} WebXSeries items`)
        setWebxseriesVideos(webxseriesData.data)
      }
      
      // Don't set currentPage here, let the URL control it
      setTotalPages(data1.total_pages || 1)
      setHasNextPage(data1.has_next_page || false)
      
      // Save the current page to the navigation context
      setWebseriesPage(pageNum)
    } catch (err) {
      console.error("Error loading webseries:", err)
      setError("Failed to load webseries. Please try again later.")
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    // Only fetch data once on initial load
    if (router.isReady && webseries.length === 0 && webxseriesVideos.length === 0) {
      loadWebseries(currentPage)
    }
  }, [router.isReady])

  // Merge and paginate combined webseries - memoized to avoid recalculation
  const mergedWebseries = useMemo(() => {
    // Transform old webseries posts
    const oldWebseries = webseries.map((post) => ({
      id: post.id,
      title: post.title,
      thumbnail: post.thumbnail,
      duration: post.duration,
      quality: post.quality || 'HD',
      link: post.link,
      source: 'webseries' as const,
      badge: 'ðŸŽ¬ Web Series',
    }))

    // Transform WebXSeries videos
    const newWebxseries = webxseriesVideos.map((video) => ({
      id: video.id || video.slug,
      title: video.title,
      thumbnail: video.thumbnail || video.thumbnailUrl,
      duration: video.duration || 'Unknown',
      quality: video.categories?.[0] || 'OTT',
      link: `/provider/webxseries/video/${video.slug}`,
      source: 'webxseries' as const,
      badge: 'ðŸ“º OTT Platform',
    }))

    // Interleave both sources: 2 old, 1 new, repeat
    const merged: MergedWebseries[] = []
    let oldIndex = 0
    let newIndex = 0
    
    // Keep merging until we run out of content from both sources
    while (oldIndex < oldWebseries.length || newIndex < newWebxseries.length) {
      // Add 2 from old webseries
      if (oldIndex < oldWebseries.length) {
        merged.push(oldWebseries[oldIndex++])
      }
      if (oldIndex < oldWebseries.length) {
        merged.push(oldWebseries[oldIndex++])
      }
      
      // Add 1 from webxseries
      if (newIndex < newWebxseries.length) {
        merged.push(newWebxseries[newIndex++])
      }
    }
    
    console.log(`Merged ${merged.length} total items (${oldWebseries.length} old + ${newWebxseries.length} new)`)
    
    return merged
  }, [webseries, webxseriesVideos])
  
  // Separate effect to handle page changes and load data if needed
  useEffect(() => {
    const checkAndLoadData = async () => {
      if (router.isReady && currentPage > 0 && (webseries.length > 0 || webxseriesVideos.length > 0)) {
        // Calculate merged count first
        const currentMergedCount = mergedWebseries.length
        const requiredItems = currentPage * itemsPerPage
        
        console.log(`[Auto-load Check] Page ${currentPage}:`)
        console.log(`  - Required items: ${requiredItems}`)
        console.log(`  - Current merged: ${currentMergedCount}`)
        console.log(`  - Old webseries: ${webseries.length}`)
        console.log(`  - WebXSeries: ${webxseriesVideos.length}`)
        
        // If we don't have enough merged data, load more
        if (currentMergedCount < requiredItems) {
          // With 2:1 interleaving ratio:
          // For every 3 merged items, we need 2 old + 1 new
          // So for N merged items: need (N * 2/3) old items
          const currentOldItems = webseries.length
          const neededOldItems = Math.ceil((requiredItems * 2) / 3)
          
          // Assuming ~12 items per page of old webseries
          const currentOldPages = Math.ceil(currentOldItems / 12)
          const neededOldPages = Math.ceil(neededOldItems / 12)
          
          console.log(`[Auto-load] Old items: have ${currentOldItems}, need ${neededOldItems}`)
          console.log(`[Auto-load] Old pages: have ${currentOldPages}, need ${neededOldPages}`)
          
          if (neededOldPages > currentOldPages) {
            const pagesToLoad = Math.min(neededOldPages - currentOldPages, 5)
            console.log(`[Auto-load] ðŸ”„ Loading ${pagesToLoad} more pages (${currentOldPages + 1} to ${currentOldPages + pagesToLoad})`)
            
            // Load the missing pages
            for (let p = currentOldPages + 1; p <= currentOldPages + pagesToLoad; p++) {
              await loadMoreWebseries(p)
            }
          } else {
            console.log(`[Auto-load] âš ï¸ Have enough old pages but merged count is still low`)
            console.log(`[Auto-load] This might be a calculation issue or data issue`)
          }
        } else {
          console.log(`[Auto-load Check] âœ… Have enough data for page ${currentPage}`)
        }
      }
    }
    
    checkAndLoadData()
  }, [router.isReady, currentPage, webseries.length, webxseriesVideos.length])

  // Separate effect for URL updates to avoid conflicts
  useEffect(() => {
    if (router.isReady && currentPage > 0) {
      if (currentPage > 1) {
        router.push(`/webseries?page=${currentPage}`, undefined, { shallow: true })
      } else {
        // Always go to clean URL for page 1
        router.push('/webseries', undefined, { shallow: true })
      }
    }
  }, [currentPage, router.isReady])

  // Get paginated merged webseries (20 per page)
  const totalItems = mergedWebseries.length
  
  // Calculate total pages: use the larger of current merged pages or API total pages
  // This ensures we can navigate to pages even before data is loaded
  const mergedPages = Math.ceil(totalItems / itemsPerPage)
  const totalPagesCalculated = Math.max(mergedPages, totalPages)
  
  const startIndex = (currentPage - 1) * itemsPerPage
  const endIndex = startIndex + itemsPerPage
  const paginatedWebseries = mergedWebseries.slice(startIndex, endIndex)
  
  console.log(`Page ${currentPage}: Showing items ${startIndex + 1}-${Math.min(endIndex, totalItems)} of ${totalItems}`)

  const handlePageChange = async (page: number) => {
    if (page < 1) return
    
    // Don't restrict by totalPagesCalculated since we load on demand
    // But check if page is within reasonable bounds (e.g., totalPages from API)
    if (totalPages > 0 && page > totalPages) return
    
    // First, update the page to show we're changing
    setCurrentPage(page)
    
    // Calculate how many items we need for this page
    const requiredItems = page * itemsPerPage
    const currentMergedCount = mergedWebseries.length
    
    console.log(`Page ${page}: Need ${requiredItems} items, have ${currentMergedCount} merged items`)
    
    // If we don't have enough merged items, load more data
    if (currentMergedCount < requiredItems) {
      // With 2:1 ratio, we need roughly 2/3 old webseries and 1/3 webxseries
      // So for N merged items, we need ~(N * 2/3 / 12) pages of old webseries
      const currentOldPages = Math.ceil(webseries.length / 12)
      const neededOldPages = Math.ceil((requiredItems * 2) / 36) // 2/3 of items, 12 per page
      
      console.log(`Current old pages: ${currentOldPages}, Needed: ${neededOldPages}`)
      
      if (neededOldPages > currentOldPages) {
        // Load the missing pages
        for (let p = currentOldPages + 1; p <= Math.min(neededOldPages, currentOldPages + 5); p++) {
          console.log(`Loading old webseries page ${p}`)
          await loadMoreWebseries(p)
        }
      }
    }
    
    // Scroll to top when changing pages
    window.scrollTo({ top: 0, behavior: "smooth" })
  }

  // When clicking on a webseries, we make sure the current page is saved
  const handleWebseriesClick = () => {
    setWebseriesPage(currentPage)
  }

  return (
    <>
      <Head>
        <title>Latest Webseries - PremiumHUB</title>
        <meta name="description" content="Watch the latest webseries on PremiumHUB." />
      </Head>

      <div className="pb-10">
        <div className="container mx-auto px-4">
          {/* Header */}
          <div className="mb-8">
            <h1 className="text-3xl font-bold text-white mb-2 flex items-center">
              <span className="w-1.5 h-8 bg-purple-500 rounded-full inline-block mr-3"></span>
              Latest Webseries & OTT Content
            </h1>
            <p className="text-gray-400 ml-4">Discover the newest webseries and OTT platform content</p>
          </div>

          {/* Error message */}
          {error && (
            <div className="bg-red-500/10 border border-red-500/50 text-red-500 px-4 py-3 rounded mb-6">{error}</div>
          )}

          {/* Webseries grid */}
          {loading && paginatedWebseries.length === 0 ? (
            <div className="flex justify-center py-12">
              <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-purple-500"></div>
            </div>
          ) : paginatedWebseries.length > 0 ? (
            <>
              <div className={`grid gap-5 mb-8 ${
                isCollapsed 
                  ? 'grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 xl:grid-cols-6' 
                  : 'grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4'
              }`}>
              {paginatedWebseries.map((series) => (
                <Link
                  key={`${series.source}-${series.id}`}
                  href={series.link}
                  onClick={handleWebseriesClick}
                  className="group flex flex-col bg-gray-800/40 rounded-xl overflow-hidden transition-all duration-300 hover:scale-[1.02] shadow-lg shadow-black/30 hover:shadow-purple-900/20"
                >
                  <div className="aspect-video relative">
                    <img
                      src={series.thumbnail || "/api/placeholder?height=400&width=600&query=webseries"}
                      alt={series.title}
                      className="w-full h-full object-cover transition-transform duration-500 group-hover:scale-105 brightness-95"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement
                        target.onerror = null
                        target.src = "/api/placeholder?height=400&width=600&query=webseries"
                      }}
                    />

                    <div className="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent opacity-60 group-hover:opacity-40 transition-opacity duration-300" />

                    {/* Play button overlay */}
                    <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300">
                      <div className="w-14 h-14 bg-purple-600/90 backdrop-blur-sm rounded-full flex items-center justify-center transform scale-75 group-hover:scale-100 transition-all duration-300 shadow-lg shadow-purple-600/30">
                        <Play className="w-7 h-7 text-white fill-current ml-1" />
                      </div>
                    </div>

                    {/* Source Badge - distinguish between old webseries and webxseries */}
                    <div className={`absolute top-3 left-3 text-white text-xs px-2.5 py-1 rounded-md shadow-md backdrop-blur-sm font-semibold ${
                      series.source === 'webxseries' 
                        ? 'bg-gradient-to-r from-cyan-500/90 to-blue-600/90' 
                        : 'bg-gradient-to-r from-purple-500/90 to-pink-600/90'
                    }`}>
                      {series.badge}
                    </div>

                    {/* Duration badge */}
                    <div className="absolute bottom-3 right-3 bg-black/80 backdrop-blur-sm text-white text-xs px-2.5 py-1 rounded-full flex items-center shadow-lg border border-white/10">
                      <Clock size={12} className="mr-1" />
                      {series.duration}
                    </div>
                  </div>
                     
                  <div className="p-3 flex-grow flex flex-col">
                    <h3 className="font-medium text-white line-clamp-2 group-hover:text-purple-300 transition-colors">
                      {series.title}
                    </h3>

                    <div className="flex items-center mt-2 text-xs text-gray-300">
                      {series.quality && (
                        <span className="bg-purple-600/80 text-white px-2 py-0.5 rounded-md text-xs">
                          {series.quality}
                        </span>
                      )}
                    </div>
                  </div>
                </Link>
              ))}
              </div>
              
              {/* Loading more indicator */}
              {loadingMore && (
                <div className="flex justify-center py-6">
                  <div className="flex items-center space-x-2 text-purple-400">
                    <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-purple-500"></div>
                    <span className="text-sm">Loading more content...</span>
                  </div>
                </div>
              )}
            </>
          ) : (
            <div className="text-center py-12 bg-gray-800/50 rounded-xl border border-gray-700/50 backdrop-blur-sm">
              <h3 className="text-xl font-medium text-gray-400">No webseries available</h3>
              <p className="text-gray-500 mt-2">Check back later for new content.</p>
            </div>
          )}

          {/* Pagination */}
          {totalPagesCalculated > 1 && (
            <div className="flex justify-center items-center space-x-2 mt-8">
              <button
                onClick={() => handlePageChange(currentPage - 1)}
                disabled={currentPage === 1 || loading}
                className="p-2 rounded-lg bg-gray-800/70 text-white hover:bg-purple-600/80 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                <ChevronLeft size={20} />
              </button>

              <div className="flex items-center space-x-1">
                {Array.from({ length: Math.min(5, totalPagesCalculated) }, (_, i) => {
                  // Show pages around current page
                  let pageNum
                  if (totalPagesCalculated <= 5) {
                    pageNum = i + 1
                  } else if (currentPage <= 3) {
                    pageNum = i + 1
                  } else if (currentPage >= totalPagesCalculated - 2) {
                    pageNum = totalPagesCalculated - 4 + i
                  } else {
                    pageNum = currentPage - 2 + i
                  }

                  // Ensure pageNum is valid
                  if (pageNum < 1 || pageNum > totalPagesCalculated) return null

                  return (
                    <button
                      key={pageNum}
                      onClick={() => handlePageChange(pageNum)}
                      disabled={loading}
                      className={`w-10 h-10 rounded-lg ${
                        currentPage === pageNum
                          ? "bg-purple-600 text-white"
                          : "bg-gray-800/70 text-white hover:bg-gray-700/80"
                      } disabled:opacity-50 disabled:cursor-not-allowed transition-colors`}
                    >
                      {pageNum}
                    </button>
                  )
                })}

                {totalPagesCalculated > 5 && currentPage < totalPagesCalculated - 2 && (
                  <>
                    <span className="text-gray-500">...</span>
                    <button
                      onClick={() => handlePageChange(totalPagesCalculated)}
                      disabled={loading}
                      className="w-10 h-10 rounded-lg bg-gray-800/70 text-white hover:bg-gray-700/80 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                    >
                      {totalPagesCalculated}
                    </button>
                  </>
                )}

                {/* Always show page 1 if not already visible and we're not on first few pages */}
                {totalPagesCalculated > 5 && currentPage > 3 && (
                  <>
                    <button
                      onClick={() => handlePageChange(1)}
                      disabled={loading}
                      className="w-10 h-10 rounded-lg bg-gray-800/70 text-white hover:bg-gray-700/80 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                    >
                      1
                    </button>
                    <span className="text-gray-500">...</span>
                  </>
                )}
              </div>

              <button
                onClick={() => handlePageChange(currentPage + 1)}
                disabled={currentPage >= totalPagesCalculated || loading}
                className="p-2 rounded-lg bg-gray-800/70 text-white hover:bg-purple-600/80 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                <ChevronRight size={20} />
              </button>
            </div>
          )}
        </div>
      </div>
    </>
  )
}
